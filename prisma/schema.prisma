generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String    @id @default(cuid())
  email           String    @unique
  emailVerified       DateTime?
  onboardingCompleted Boolean   @default(false)
  passwordHash    String
  username        String    @unique
  currentLevel    Int       @default(1)
  lessonsPerDay   Int       @default(15)
  lessonBatchSize Int       @default(5)   // Learn 5, quiz 5, repeat (WaniKani-style)
  reviewBatchSize Int       @default(10)
  autoplayAudio   Boolean   @default(true)
  createdAt       DateTime  @default(now())

  // Admin & Suspension
  isAdmin       Boolean   @default(false)
  isSuspended   Boolean   @default(false)
  suspendedAt   DateTime?
  suspendedBy   String?
  suspendReason String?

  // Gamification & Streaks
  currentStreak     Int       @default(0)
  longestStreak     Int       @default(0)
  lastStudyDate     DateTime?
  totalXp           Int       @default(0)
  weeklyXp          Int       @default(0)
  weeklyXpResetAt   DateTime  @default(now())
  totalReviewsDone  Int       @default(0)
  totalLessonsDone  Int       @default(0)
  perfectDays       Int       @default(0)  // Days with 100% accuracy

  // AI Mnemonic Credits
  mnemonicCredits   Int       @default(0)  // Paid credits for regeneration

  // XP Rewards System
  selectedTheme     String    @default("default")  // Current active theme
  unlockedThemes    String[]  @default(["default"]) // Themes user has purchased
  unlockedBadges    String[]  @default([])         // Badges user has earned

  // Tanuki Pet System
  tanukiName        String?                        // User's custom name for their Tanuki
  tanukiSkin        String    @default("classic")  // Current skin (classic, ninja, sakura, etc.)
  unlockedSkins     String[]  @default(["classic"]) // Skins user has purchased

  // Email Notification Preferences
  emailNotificationsEnabled  Boolean   @default(true)
  notifyReviewsWaiting       Boolean   @default(true)
  notifyStreakAtRisk         Boolean   @default(true)
  notifyLevelUp              Boolean   @default(true)
  notifyReengagement         Boolean   @default(true)
  notifyWeeklySummary        Boolean   @default(true)

  // Notification Timing
  preferredNotificationHour  Int       @default(9)   // 0-23 hour in user's timezone
  timezone                   String    @default("Europe/Paris")

  // Anti-spam tracking
  lastReviewsWaitingEmail    DateTime?
  lastStreakAtRiskEmail      DateTime?
  lastReengagementEmail      DateTime?
  lastWeeklySummaryEmail     DateTime?

  // One-click unsubscribe token
  unsubscribeToken           String?   @unique

  // AI Feedback settings
  aiFeedbackEnabled     Boolean   @default(true)
  lastPatternAnalysis   DateTime?

  // Level-Aware Sentences setting
  levelAwareSentencesEnabled  Boolean   @default(true)

  // Personalized AI Mnemonics
  interests         String[]  @default([])  // ["gaming", "cooking", "football", "cinema", "music"]

  // JLPT Mock Tests
  jlptMockTests     JLPTMockTest[]

  // Leaderboard & Analytics
  leaderboardOptIn  Boolean   @default(false)

  // Subscription & Billing
  subscriptionStatus            String    @default("free")  // 'free' | 'active' | 'canceled' | 'past_due' | 'lifetime'
  subscriptionPlan              String?   // 'monthly' | 'yearly' | 'lifetime'
  stripeCustomerId              String?   @unique
  stripeSubscriptionId          String?   @unique
  subscriptionCurrentPeriodEnd  DateTime?
  subscriptionCancelAtPeriodEnd Boolean   @default(false)
  lifetimePurchasedAt           DateTime?

  // Progress relations
  radicalProgress    UserRadicalProgress[]
  kanjiProgress      UserKanjiProgress[]
  vocabularyProgress UserVocabularyProgress[]
  grammarProgress    UserGrammarProgress[]
  reviews            Review[]

  // Token relations
  emailVerificationTokens EmailVerificationToken[]
  emailChangeTokens       EmailChangeToken[]
  notificationLogs        NotificationLog[]

  // AI Feedback relations
  reviewMistakes     ReviewMistake[]
  weaknessPatterns   UserWeaknessPattern[]

  // Level-Aware Sentences cache
  sentenceCache      UserSentenceCache[]

  // Analytics relations
  levelHistory       UserLevelHistory[]
  dailyStats         UserDailyStats[]

  // Admin audit relations
  adminActions AdminAuditLog[] @relation("AdminPerformer")
}

model Level {
  id            Int            @id @default(autoincrement())
  name          String?
  radicals      Radical[]
  kanji         Kanji[]
  vocabulary    Vocabulary[]
  grammarPoints GrammarPoint[]
}

model Radical {
  id            Int     @id @default(autoincrement())
  character     String? // null if image-only radical
  meaningFr     String
  meaningHintFr String?
  mnemonic      String  @db.Text
  imageUrl      String? // for radicals without unicode
  levelId       Int
  level         Level   @relation(fields: [levelId], references: [id])

  // Metadata for reorganization
  usageCount    Int?    // How many kanji use this radical
  complexity    Int?    // Visual complexity (1-5)

  kanji        KanjiRadical[]
  userProgress UserRadicalProgress[]

  @@index([levelId])
}

model Kanji {
  id                Int      @id @default(autoincrement())
  character         String   @unique
  meaningsFr        String[] // array of accepted meanings
  readingsOn        String[] // onyomi readings
  readingsKun       String[] // kunyomi readings
  meaningMnemonicFr String   @db.Text
  readingMnemonicFr String   @db.Text
  levelId           Int
  level             Level    @relation(fields: [levelId], references: [id])

  // JLPT and frequency metadata
  jlptLevel         Int?     // 5=N5, 4=N4, 3=N3, 2=N2, 1=N1
  frequencyRank     Int?     // 1-2500 newspaper frequency
  gradeLevel        Int?     // Japanese school grade (1-6 for Joyo)
  strokeCount       Int?     // Number of strokes

  radicals     KanjiRadical[]
  vocabulary   VocabularyKanji[]
  userProgress UserKanjiProgress[]
  etymologyCache KanjiEtymologyCache?

  @@index([levelId])
  @@index([jlptLevel])
}

model Vocabulary {
  id         Int      @id @default(autoincrement())
  word       String
  meaningsFr String[]
  readings   String[] // kana readings
  mnemonicFr String   @db.Text
  sentenceJp String?
  sentenceFr String?
  levelId    Int
  level      Level    @relation(fields: [levelId], references: [id])

  // JLPT and frequency metadata
  jlptLevel     Int?  // 5=N5, 4=N4, 3=N3, 2=N2, 1=N1
  frequencyRank Int?  // Word frequency rank

  kanji         VocabularyKanji[]
  userProgress  UserVocabularyProgress[]
  sentenceCache UserSentenceCache[]

  @@index([levelId])
  @@index([jlptLevel])
}

// Junction tables
model KanjiRadical {
  kanjiId   Int
  radicalId Int
  kanji     Kanji   @relation(fields: [kanjiId], references: [id])
  radical   Radical @relation(fields: [radicalId], references: [id])

  @@id([kanjiId, radicalId])
}

model VocabularyKanji {
  vocabularyId Int
  kanjiId      Int
  vocabulary   Vocabulary @relation(fields: [vocabularyId], references: [id])
  kanji        Kanji      @relation(fields: [kanjiId], references: [id])

  @@id([vocabularyId, kanjiId])
}

// Progress Tracking
model UserRadicalProgress {
  userId           String
  radicalId        Int
  srsStage         Int       @default(0) // 0=locked, 1-4=apprentice, 5-6=guru, 7=master, 8=enlightened, 9=burned
  unlockedAt       DateTime?
  nextReviewAt     DateTime?
  meaningCorrect   Int       @default(0)
  meaningIncorrect Int       @default(0)
  customMnemonic   String?   @db.Text // User's custom AI-generated mnemonic

  user    User    @relation(fields: [userId], references: [id])
  radical Radical @relation(fields: [radicalId], references: [id])

  @@id([userId, radicalId])
  @@index([userId, srsStage])
  @@index([userId, nextReviewAt])
  @@index([userId, srsStage, nextReviewAt]) // Compound index for review queries
}

model UserKanjiProgress {
  userId           String
  kanjiId          Int
  srsStage         Int       @default(0)
  unlockedAt       DateTime?
  nextReviewAt     DateTime?
  meaningCorrect   Int       @default(0)
  meaningIncorrect Int       @default(0)
  readingCorrect   Int       @default(0)
  readingIncorrect Int       @default(0)
  customMeaningMnemonic  String?   @db.Text // Custom mnemonic for meaning
  customReadingMnemonic  String?   @db.Text // Custom mnemonic for reading

  user  User  @relation(fields: [userId], references: [id])
  kanji Kanji @relation(fields: [kanjiId], references: [id])

  @@id([userId, kanjiId])
  @@index([userId, srsStage])
  @@index([userId, nextReviewAt])
  @@index([userId, srsStage, nextReviewAt]) // Compound index for review queries
}

model UserVocabularyProgress {
  userId           String
  vocabularyId     Int
  srsStage         Int       @default(0)
  unlockedAt       DateTime?
  nextReviewAt     DateTime?
  meaningCorrect   Int       @default(0)
  meaningIncorrect Int       @default(0)
  readingCorrect   Int       @default(0)
  readingIncorrect Int       @default(0)
  customMnemonic   String?   @db.Text // User's custom AI-generated mnemonic

  user       User       @relation(fields: [userId], references: [id])
  vocabulary Vocabulary @relation(fields: [vocabularyId], references: [id])

  @@id([userId, vocabularyId])
  @@index([userId, srsStage])
  @@index([userId, nextReviewAt])
  @@index([userId, srsStage, nextReviewAt]) // Compound index for review queries
}

model Review {
  id           String   @id @default(cuid())
  userId       String
  itemType     String // 'radical' | 'kanji' | 'vocabulary'
  itemId       Int
  reviewType   String // 'meaning' | 'reading'
  correct      Boolean
  srsStageFrom Int
  srsStageTo   Int
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  email     String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([email])
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  email     String
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([email])
  @@index([userId])
}

model EmailChangeToken {
  id        String   @id @default(cuid())
  userId    String
  newEmail  String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model AdminAuditLog {
  id         String   @id @default(cuid())
  adminId    String
  action     String   // e.g., 'user.suspend', 'content.create', 'content.update'
  targetType String   // e.g., 'user', 'radical', 'kanji', 'vocabulary', 'level'
  targetId   String   // ID of the affected record
  details    Json?    // Additional context (old values, new values, etc.)
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())

  admin User @relation("AdminPerformer", fields: [adminId], references: [id])

  @@index([adminId, createdAt])
  @@index([targetType, targetId])
  @@index([createdAt])
}

// Shared AI-generated mnemonics (cache for all users)
model SharedMnemonic {
  id            String   @id @default(cuid())
  itemType      String   // 'radical' | 'kanji' | 'vocabulary'
  itemId        Int
  mnemonicType  String   // 'meaning' | 'reading'
  content       String   @db.Text
  createdAt     DateTime @default(now())
  usageCount    Int      @default(1)  // Track how many users use this

  @@unique([itemType, itemId, mnemonicType])
  @@index([itemType, itemId])
}

// Email notification tracking (for debugging and analytics)
model NotificationLog {
  id        String   @id @default(cuid())
  userId    String
  type      String   // 'reviews_waiting' | 'streak_at_risk' | 'level_up' | 'reengagement' | 'weekly_summary'
  sentAt    DateTime @default(now())
  success   Boolean
  error     String?
  metadata  Json?    // Store context like reviewCount, streakDays, etc.

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, type, sentAt])
  @@index([sentAt])
}

// Customizable email templates (admin-editable)
model EmailTemplate {
  id          String   @id @default(cuid())
  type        String   @unique  // 'reviews_waiting' | 'streak_at_risk' | 'level_up' | 'reengagement' | 'weekly_summary' | 'password_reset' | 'verification' | 'email_change' | 'admin_password_reset'
  subject     String   @db.Text
  headline    String   @db.Text
  bodyText    String   @db.Text
  buttonText  String
  footerText  String?  @db.Text
  isActive    Boolean  @default(true)
  updatedAt   DateTime @updatedAt
  updatedBy   String?  // Admin who last updated
}

// Store user's wrong answers for pattern analysis
model ReviewMistake {
  id             String   @id @default(cuid())
  userId         String
  itemType       String   // 'radical' | 'kanji' | 'vocabulary'
  itemId         Int
  reviewType     String   // 'meaning' | 'reading'
  userAnswer     String   // What the user typed
  correctAnswers String[] // Expected answers
  feedbackShown  String?  @db.Text // AI feedback shown (for analytics)
  createdAt      DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([userId, itemType, itemId])
}

// Cache for common mistake feedback (avoid redundant AI calls)
model MistakeFeedbackCache {
  id                 String   @id @default(cuid())
  itemType           String   // 'radical' | 'kanji' | 'vocabulary'
  itemId             Int
  reviewType         String   // 'meaning' | 'reading'
  wrongAnswerPattern String   // Normalized wrong answer
  feedback           String   @db.Text
  usageCount         Int      @default(1)
  createdAt          DateTime @default(now())

  @@unique([itemType, itemId, reviewType, wrongAnswerPattern])
  @@index([itemType, itemId])
}

// User's detected weakness patterns
model UserWeaknessPattern {
  id            String   @id @default(cuid())
  userId        String
  patternType   String   // 'visual_confusion' | 'reading_confusion' | 'translation_nuance'
  description   String   @db.Text // AI-generated French description
  affectedItems Json     // [{type, id, character}...]
  mistakeCount  Int
  severity      Float    // 0-1 for prioritization
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, severity])
  @@index([userId, patternType])
}

// Level-Aware Example Sentences Cache (per user, per vocabulary)
model UserSentenceCache {
  id                  String   @id @default(cuid())
  userId              String
  vocabularyId        Int
  sentences           Json     // Array of SentenceData objects
  masteredKanjiHash   String   // Hash of user's mastered kanji at generation time
  masteredVocabCount  Int      // Count of mastered vocab at generation time
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  vocabulary Vocabulary @relation(fields: [vocabularyId], references: [id], onDelete: Cascade)

  @@unique([userId, vocabularyId])
  @@index([userId])
  @@index([vocabularyId])
}

// Track user level-up history for progress visualization
model UserLevelHistory {
  id        String   @id @default(cuid())
  userId    String
  level     Int
  reachedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([reachedAt])
}

// Daily aggregated stats for analytics charts (reduces query load)
model UserDailyStats {
  id               String   @id @default(cuid())
  userId           String
  date             DateTime @db.Date
  reviewsCompleted Int      @default(0)
  lessonsCompleted Int      @default(0)
  correctCount     Int      @default(0)
  incorrectCount   Int      @default(0)
  xpEarned         Int      @default(0)
  studyTimeMinutes Int      @default(0)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@index([userId])
  @@index([date])
}

// ============================================
// JLPT MOCK TEST SYSTEM
// ============================================

model JLPTMockTest {
  id              String    @id @default(cuid())
  userId          String
  jlptLevel       Int       // 5, 4, 3, 2, 1 (N5, N4, N3, N2, N1)

  // Timing
  startedAt       DateTime  @default(now())
  completedAt     DateTime?
  timeSpentMinutes Int?

  // Scores (percentage 0-100)
  vocabularyScore Float?
  grammarScore    Float?
  readingScore    Float?
  listeningScore  Float?
  totalScore      Float?
  passed          Boolean?  // >= 60% to pass

  // AI Analysis (generated after completion)
  weakAreas       Json?     // ["kanji_reading", "grammar_particles", "time_expressions"]
  studyPlan       Json?     // AI-generated 30-day personalized plan
  analysisText    String?   @db.Text  // Human-readable AI analysis in French

  // Integration tracking
  weakItemsAddedToSRS  Boolean   @default(false)  // Have we boosted weak items?
  studyPlanStartedAt   DateTime?

  answers         JLPTTestAnswer[]
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, jlptLevel])
  @@index([completedAt])
}

model JLPTTestAnswer {
  id            String   @id @default(cuid())
  testId        String
  questionId    Int

  // Answer data
  userAnswer    String
  isCorrect     Boolean
  timeSpentSecs Int?

  // AI explanation (generated for wrong answers)
  aiExplanation String?  @db.Text  // Why wrong + how to remember

  test          JLPTMockTest @relation(fields: [testId], references: [id], onDelete: Cascade)
  question      JLPTQuestion @relation(fields: [questionId], references: [id])

  @@index([testId])
}

model JLPTQuestion {
  id            Int      @id @default(autoincrement())
  jlptLevel     Int      // 5, 4, 3, 2, 1
  section       String   // "vocabulary" | "grammar" | "reading" | "listening"
  questionType  String   // "meaning" | "reading" | "usage" | "fill_blank" | "passage" | "audio"

  // Question content
  questionText  String   @db.Text
  questionAudio String?  // URL to audio file (for listening)
  passageText   String?  @db.Text  // Reading passage (for reading section)

  // Options (for multiple choice)
  options       String[]
  correctIndex  Int      // 0-3 for which option is correct

  // Explanation
  explanation   String   @db.Text  // Why this answer is correct

  // Links to app content (for integration)
  relatedKanji  String[] // ["日", "本", "語"]
  relatedVocab  String[] // ["日本語", "日本人"]
  grammarPoint  String?  // "te-form", "passive", etc.

  // Metadata
  difficulty    Int      @default(1)  // 1-3 within the JLPT level
  createdAt     DateTime @default(now())

  answers       JLPTTestAnswer[]

  @@index([jlptLevel, section])
  @@index([jlptLevel, difficulty])
}

// Track which JLPT levels user has unlocked (based on app level)
model UserJLPTAccess {
  id            String   @id @default(cuid())
  userId        String
  jlptLevel     Int      // 5, 4, 3, 2, 1
  unlockedAt    DateTime @default(now())
  freeTestUsed  Boolean  @default(false)  // Has used their 1 free test?

  @@unique([userId, jlptLevel])
  @@index([userId])
}

// ============================================
// KANJI ETYMOLOGY CACHE
// ============================================

// Cache for AI-generated kanji etymology explanations (global, same for all users)
model KanjiEtymologyCache {
  id            String   @id @default(cuid())
  kanjiId       Int      @unique
  character     String
  etymology     String   @db.Text  // AI-generated etymology explanation in French
  origin        String   // "pictographic" | "ideographic" | "compound"
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  kanji         Kanji    @relation(fields: [kanjiId], references: [id], onDelete: Cascade)

  @@index([kanjiId])
}

// ============================================
// GRAMMAR SRS SYSTEM (Bunpro-style)
// ============================================

// A grammar concept to learn (unlocks alongside kanji at each level)
model GrammarPoint {
  id                Int      @id @default(autoincrement())
  levelId           Int      // Which level this unlocks at
  jlptLevel         Int      // 5=N5, 4=N4, 3=N3, 2=N2, 1=N1
  slug              String   @unique // URL-friendly identifier
  titleJp           String   // Japanese title (e.g., "～てform")
  titleFr           String   // French title
  meaningFr         String   @db.Text // French meaning/usage
  formation         String   @db.Text // How to form it
  formationNotes    String?  @db.Text // Additional formation notes
  exampleSentences  Json     // Array of {japanese, french, audio?}
  nuancesFr         String?  @db.Text // Nuances and usage notes in French
  mnemonicFr        String   @db.Text // French mnemonic
  relatedGrammar    Int[]    // IDs of related grammar points
  order             Int      @default(0) // Order within level

  level             Level    @relation(fields: [levelId], references: [id])
  userProgress      UserGrammarProgress[]

  @@index([levelId])
  @@index([jlptLevel])
}

// User's SRS progress on grammar
model UserGrammarProgress {
  id              String    @id @default(cuid())
  userId          String
  grammarId       Int
  srsStage        Int       @default(0) // 0=locked, 1-4=apprentice, 5-6=guru, 7=master, 8=enlightened, 9=burned
  correctCount    Int       @default(0)
  incorrectCount  Int       @default(0)
  nextReviewAt    DateTime?
  unlockedAt      DateTime?
  burnedAt        DateTime?

  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  grammar         GrammarPoint @relation(fields: [grammarId], references: [id], onDelete: Cascade)

  @@unique([userId, grammarId])
  @@index([userId, srsStage])
  @@index([userId, nextReviewAt])
}
